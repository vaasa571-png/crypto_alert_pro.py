import logging
import os
import random
from datetime import datetime, timedelta
from dotenv import load_dotenv
import requests
import asyncio
import matplotlib.pyplot as plt
import io
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice, ReplyKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    PreCheckoutQueryHandler,
    MessageHandler,
    filters,
)
import telegram

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    filename="B:/Bot/CryptoAlert Pro/crypto_alert_pro.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ python-telegram-bot
logger.info(f"python-telegram-bot version: {telegram.__version__}")
print(f"üìö python-telegram-bot version: {telegram.__version__}")

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ .env
def check_env_encoding():
    try:
        with open("B:/Bot/CryptoAlert Pro/.env", "rb") as f:
            first_bytes = f.read(3)
            if first_bytes == b"\xEF\xBB\xBF":
                logger.error("‚ùå .env file has UTF-8 BOM. Please save it as UTF-8 without BOM.")
                print("‚ùå .env file has UTF-8 BOM. Please save it as UTF-8 without BOM.")
                exit(1)
    except Exception as e:
        logger.error(f"Failed to check .env encoding: {e}")
        print(f"‚ùå Failed to check .env encoding: {e}")
        exit(1)

check_env_encoding()

# –ó–∞–≥—Ä—É–∑–∫–∞ .env
try:
    load_dotenv(dotenv_path="B:/Bot/CryptoAlert Pro/.env", encoding="utf-8")
except Exception as e:
    logger.error(f"Failed to load .env: {e}")
    print(f"‚ùå Failed to load .env: {e}")
    exit(1)

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
if not TELEGRAM_TOKEN:
    logger.error("‚ùå TELEGRAM_TOKEN not set in .env!")
    print("‚ùå TELEGRAM_TOKEN not set in .env!")
    exit(1)

# –£–¥–∞–ª–µ–Ω–∏–µ –∫–∞–≤—ã—á–µ–∫, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
TELEGRAM_TOKEN = TELEGRAM_TOKEN.strip('"').strip("'")

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
async def test_token():
    try:
        from telegram import Bot
        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            me = await bot.get_me()
            print(f"‚úÖ Bot authorized: {me.first_name}, ID: {me.id}")
            return True
    except Exception as e:
        logger.error(f"Failed to validate token: {e}")
        print(f"‚ùå Failed to validate token: {e}")
        return False

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ ADMIN_ID –∏ PREMIUM_USERS
ADMIN_ID = 5722019324
PREMIUM_USERS = {ADMIN_ID: "forever"}

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
balance = {'USDT': 10000, 'BTC': 0.0}
user_settings = {}
user_portfolio = {}
user_referrals = {}
user_premium = {}
user_language = {}

# –°–ø–∏—Å–æ–∫ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –º–æ–Ω–µ—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤—ã–±–æ—Ä–∞
POPULAR_COINS = {
    'btc': 'bitcoin',
    'eth': 'ethereum',
    'bnb': 'binancecoin',
    'ada': 'cardano',
    'doge': 'dogecoin',
    'dot': 'polkadot',
    'sol': 'solana',
    'matic': 'matic-network',
    'xrp': 'ripple',
    'ltc': 'litecoin',
    'avax': 'avalanche-2',
    'link': 'chainlink',
    'atom': 'cosmos',
    'uni': 'uniswap',
    'trx': 'tron'
}

REFERRAL_PROGRAMS = {
    'binance': {
        'code': 'CPA_00C6KNYGXM',
        'link': 'https://www.binance.com/activity/referral-entry/CPA?ref=CPA_00C6KNYGXM',
        'bonus': '$10 + 10% —Å–∫–∏–¥–∫–∞ –Ω–∞ –∫–æ–º–∏—Å—Å–∏–∏',
        'description': 'üî• –ö—Ä—É–ø–Ω–µ–π—à–∞—è –±–∏—Ä–∂–∞ —Å –Ω–∏–∑–∫–∏–º–∏ –∫–æ–º–∏—Å—Å–∏—è–º–∏',
        'commission': '40% –æ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π'
    },
    'bybit': {
        'code': 'QZ5JJWP',
        'link': 'https://www.bybit.com/invite?ref=QZ5JJWP',
        'bonus': '$30 –±–æ–Ω—É—Å + 20% —Å–∫–∏–¥–∫–∞',
        'description': 'üöÄ –õ—É—á—à–∏–µ —Ñ—å—é—á–µ—Ä—Å—ã –∏ –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥',
        'commission': '30% –æ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π'
    },
    'kucoin': {
        'code': '–¢–í–û–ô_–†–ï–ê–õ–¨–ù–´–ô_–ö–û–î',  # ‚ö†Ô∏è –ó–ê–ú–ï–ù–ò!
        'link': 'https://www.kucoin.com/ucenter/signup?rcode=–¢–í–û–ô_–†–ï–ê–õ–¨–ù–´–ô_–ö–û–î',
        'bonus': '500 USDT –±–æ–Ω—É—Å + 20% —Å–∫–∏–¥–∫–∞',
        'description': 'üíé 700+ –º–æ–Ω–µ—Ç, —Å—Ç–µ–π–∫–∏–Ω–≥',
        'commission': '45% –æ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π'
    },
    'mexc': {
        'code': '3XewK',
        'link': 'https://promote.mexc.com/r/V8chbeUA',
        'bonus': '1000 USDT –±–æ–Ω—É—Å + 10% —Å–∫–∏–¥–∫–∞',
        'description': 'üìà –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è, –º–Ω–æ–≥–æ –∞–ª—å—Ç–∫–æ–∏–Ω–æ–≤',
        'commission': '35% –æ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π'
    },
    'gateio': {
        'code': 'VVZGVA1ZUW',
        'link': 'https://www.gate.com/signup/VVZGVA1ZUW?ref_type=103',
        'bonus': '$100 –±–æ–Ω—É—Å + 20% —Å–∫–∏–¥–∫–∞',
        'description': 'üõ°Ô∏è –ù–∞–¥—ë–∂–Ω–∞—è –±–∏—Ä–∂–∞ —Å 2013 –≥–æ–¥–∞',
        'commission': '25% –æ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π'
    }
}

# –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —è–∑—ã–∫–æ–≤
LANGUAGES = {
    'en': {
        'welcome': "Welcome to CryptoAlert Pro! üöÄ",
        'commands': "Available Commands",
        'help_start': "Start the bot and show menu",
        'help_price': "Check current price",
        'help_alert': "Set price alerts",
        'help_portfolio_add': "Add to portfolio",
        'help_portfolio_view': "View portfolio",
        'help_arbitrage': "Premium: arbitrage opportunities",
        'help_trend': "Trend analysis",
        'help_exchanges': "Best exchanges with bonuses",
        'help_premium': "Premium subscription ($4.99)",
        'help_status': "Check premium status",
        'help_coins': "List of available coins",
        'help_chart': "Price chart for 24h",
        'help_calc_profit': "Profit calculator",
        'help_commands': "List of commands",
        'help_admin': "Admin panel",
        'help_testpremium': "Test payment (1 Star)",
        'help_stats': "Bot statistics",
        'price': "{}:\nPrice: ${:,.2f} USDT\n24h Change: {:+.2f}%",
        'alert_set': "üîî Alert set for {}: notify on ¬±{}% price change (not active yet)",
        'alert_usage': "Usage: /alert <coin> <percent>",
        'error_invalid_percent': "‚ùå Invalid percent format.",
        'portfolio_empty': "üìÇ Your portfolio is empty.",
        'portfolio': "Your portfolio",
        'portfolio_usage': "Usage:\n/portfolio add <coin> <amount> <invested>\n/portfolio view",
        'portfolio_add_usage': "Usage: /portfolio add <coin> <amount> <invested>",
        'portfolio_added': "Added {} {} to portfolio (invested: ${:,.2f} USDT)",
        'error_invalid_value': "‚ùå Invalid amount or invested value format.",
        'premium': "üëë Premium Features ($4.99/month)",
        'referral': "Your referral code: `{}`",
        'premium_success': "üéâ Premium activated for 30 days!\nUnlock: arbitrage, RSI/MACD, priority alerts.\nTry /arbitrage",
        'premium_status': "Premium Status: {}\nExpires: {}",
        'premium_status_admin': "Admin Forever üëë",
        'premium_expiry_never': "Never expires",
        'premium_status_active': "Active ‚úÖ",
        'premium_status_inactive': "Inactive ‚ùå",
        'premium_expiry_none': "N/A",
        'admin_premium': "üéâ Admin Premium activated FOREVER!\nAll features unlocked.\nTry /arbitrage",
        'test_premium': "Test Premium invoice sent (1 Star)!\nPay to check balance in @BotFather.",
        'test_premium_success': "‚úÖ Test payment successful!\nPremium activated for 30 days.\nCheck balance in @BotFather ‚Üí Payments ‚Üí Balance",
        'admin_only': "‚ùå Access denied. Admin only.",
        'admin_status': "üîß Admin Panel:\nPremium: Forever ‚úÖ\nUsers: {}\nActive Premium: {}",
        'admin_commands': "üîß Admin Commands",
        'arbitrage_locked': "üîí Arbitrage is a PREMIUM feature!\nUse /premium to subscribe ($4.99/month).",
        'arbitrage_opportunity': "üí° Arbitrage opportunity! Exchange 1: ${:,.2f} USDT, Exchange 2: ${:,.2f} USDT, Spread: ${:,.2f} USDT",
        'arbitrage_none': "‚ùå No arbitrage opportunities found.",
        'intro': (
            "üéâ **Welcome to CryptoAlert Pro!** üöÄ\n\n"
            "I'll help you track cryptocurrencies!\n"
            "1Ô∏è‚É£ **Prices**: Use /price <coin> or buttons below.\n"
            "2Ô∏è‚É£ **Portfolio**: Add assets with /portfolio add.\n"
            "3Ô∏è‚É£ **Alerts**: Set alerts with /alert.\n"
            "4Ô∏è‚É£ **Premium**: Unlock arbitrage with /premium.\n"
            "5Ô∏è‚É£ **Exchanges**: Best trading platforms with bonuses üí∞\n\n"
            "Select an action below!"
        ),
        'select_coin': "Select a coin:",
        'select_action': "Select an action:",
        'select_language': "Select language:",
        'language_set': "‚úÖ Language set: {}",
        'stats': "üìä **Bot Statistics**\nTotal Users: {}\nActive Premium: {}\nReferrals: {}",
        'calc_profit': (
            "**Profit Calculator for {}**\n"
            "Amount: {}\n"
            "Buy Price: ${:,.2f}\n"
            "Current Price: ${:,.2f}\n"
            "Profit/Loss: ${:+,.2f}"
        ),
        'calc_profit_usage': "Usage: /calc_profit <coin> <amount> <buy_price>",
        'coins': "üìà Available Coins:\n{}",
        'error_price': "‚ùå Error fetching price.",
        'error_trend': "‚ùå Error fetching trend.",
        'error_coins': "‚ùå Error fetching coin list.",
        'chart_error': "‚ùå Error generating chart.",
        'chart_xlabel': "Time",
        'chart_ylabel': "Price (USD)",
        'chart_title': "{} Price Chart (24h)",
        'exchanges': "üí∞ **Best Crypto Exchanges**\n\nChoose platform:",
        'exchange_info': "**{}**\n{}\n\nüéÅ Bonus: {}\nüí∞ Your commission: {}\n\nüîó Your referral link:",
        'ref_earnings': "üí∏ **Your Earnings from Referrals**\n\nYou earn commission from trading fees of users who register via your links:\n\n‚Ä¢ Binance: 40% of their trading fees\n‚Ä¢ Bybit: 30% of their trading fees\n‚Ä¢ KuCoin: 45% of their trading fees\n‚Ä¢ MEXC: 35% of their trading fees\n‚Ä¢ Gate.io: 25% of their trading fees\n\nüí∞ Passive income from each referred trader!",
        'setup_ref': "üîß **How to setup referral links:**\n\n1. Register on each exchange affiliate program\n2. Get your unique referral codes\n3. Replace 'YOUR_CODE' in bot settings\n4. Share links and earn passive income!",
        'binance_info': "üíé Best exchange for trading",
        'custom_coins': "ü™ô Your Custom Coins",
        'add_custom_coin': "‚ûï Add Custom Coin",
        'manage_custom_coins': "‚öôÔ∏è Manage Custom Coins",
        'custom_coin_added': "‚úÖ Custom coin '{}' added successfully!",
        'custom_coin_removed': "üóëÔ∏è Custom coin '{}' removed successfully!",
        'enter_coin_id': "Please enter the CoinGecko ID for the coin you want to add.\n\nExample: bitcoin, ethereum, cardano\n\nYou can find coin IDs at: https://www.coingecko.com",
        'no_custom_coins': "You haven't added any custom coins yet.",
        'custom_coins_list': "Your custom coins:\n{}"
    },
    'ru': {
        'welcome': "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ CryptoAlert Pro! üöÄ",
        'commands': "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã",
        'help_start': "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∏ –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é",
        'help_price': "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É",
        'help_alert': "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ü–µ–Ω–µ",
        'help_portfolio_add': "–î–æ–±–∞–≤–∏—Ç—å –≤ –ø–æ—Ä—Ç—Ñ–µ–ª—å",
        'help_portfolio_view': "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—å",
        'help_arbitrage': "–ü—Ä–µ–º–∏—É–º: –∞—Ä–±–∏—Ç—Ä–∞–∂",
        'help_trend': "–ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–æ–≤",
        'help_exchanges': "–õ—É—á—à–∏–µ –±–∏—Ä–∂–∏ —Å –±–æ–Ω—É—Å–∞–º–∏",
        'help_premium': "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –ø—Ä–µ–º–∏—É–º ($4.99)",
        'help_status': "–°—Ç–∞—Ç—É—Å –ø—Ä–µ–º–∏—É–º",
        'help_coins': "–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–Ω–µ—Ç",
        'help_chart': "–ì—Ä–∞—Ñ–∏–∫ —Ü–µ–Ω—ã –∑–∞ 24—á",
        'help_calc_profit': "–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–∏–±—ã–ª–∏",
        'help_commands': "–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥",
        'help_admin': "–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å",
        'help_testpremium': "–¢–µ—Å—Ç–æ–≤—ã–π –ø–ª–∞—Ç—ë–∂ (1 Star)",
        'help_stats': "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞",
        'price': "{}:\n–¶–µ–Ω–∞: ${:,.2f} USDT\n–ò–∑–º–µ–Ω–µ–Ω–∏–µ 24—á: {:+.2f}%",
        'alert_set': "üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è {}: –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ ¬±{}% (–ø–æ–∫–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–æ)",
        'alert_usage': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /alert <–º–æ–Ω–µ—Ç–∞> <–ø—Ä–æ—Ü–µ–Ω—Ç>",
        'error_invalid_percent': "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞.",
        'portfolio_empty': "üìÇ –í–∞—à –ø–æ—Ä—Ç—Ñ–µ–ª—å –ø—É—Å—Ç.",
        'portfolio': "–í–∞—à –ø–æ—Ä—Ç—Ñ–µ–ª—å",
        'portfolio_usage': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n/portfolio add <–º–æ–Ω–µ—Ç–∞> <–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ> <–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ>\n/portfolio view",
        'portfolio_add_usage': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /portfolio add <–º–æ–Ω–µ—Ç–∞> <–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ> <–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ>",
        'portfolio_added': "–î–æ–±–∞–≤–ª–µ–Ω–æ {} {} –≤ –ø–æ—Ä—Ç—Ñ–µ–ª—å (–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ: ${:,.2f} USDT)",
        'error_invalid_value': "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏–ª–∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π.",
        'premium': "üëë –ü—Ä–µ–º–∏—É–º —Ñ—É–Ω–∫—Ü–∏–∏ ($4.99/–º–µ—Å)",
        'referral': "–í–∞—à —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥: `{}`",
        'premium_success': "üéâ –ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 30 –¥–Ω–µ–π!\n–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã: –∞—Ä–±–∏—Ç—Ä–∞–∂, RSI/MACD, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∞–ª–µ—Ä—Ç—ã.\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ /arbitrage",
        'premium_status': "–°—Ç–∞—Ç—É—Å –ü—Ä–µ–º–∏—É–º: {}\n–ò—Å—Ç–µ–∫–∞–µ—Ç: {}",
        'premium_status_admin': "–ê–¥–º–∏–Ω –ù–∞–≤—Å–µ–≥–¥–∞ üëë",
        'premium_expiry_never': "–ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∏—Å—Ç–µ–∫–∞–µ—Ç",
        'premium_status_active': "–ê–∫—Ç–∏–≤–µ–Ω ‚úÖ",
        'premium_status_inactive': "–ù–µ –∞–∫—Ç–∏–≤–µ–Ω ‚ùå",
        'premium_expiry_none': "–ù/–î",
        'admin_premium': "üéâ –ê–¥–º–∏–Ω—Å–∫–∏–π –ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –ù–ê–í–°–ï–ì–î–ê!\n–í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ /arbitrage",
        'test_premium': "–¢–µ—Å—Ç–æ–≤—ã–π –∏–Ω–≤–æ–π—Å –ü—Ä–µ–º–∏—É–º –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω (1 Star)!\n–û–ø–ª–∞—Ç–∏—Ç–µ, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –±–∞–ª–∞–Ω—Å –≤ @BotFather.",
        'test_premium_success': "‚úÖ –¢–µ—Å—Ç–æ–≤—ã–π –ø–ª–∞—Ç—ë–∂ —É—Å–ø–µ—à–µ–Ω!\n–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 30 –¥–Ω–µ–π.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –±–∞–ª–∞–Ω—Å –≤ @BotFather ‚Üí –ü–ª–∞—Ç–µ–∂–∏ ‚Üí –ë–∞–ª–∞–Ω—Å",
        'admin_only': "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω. –¢–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞.",
        'admin_status': "üîß –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:\n–ü—Ä–µ–º–∏—É–º: –ù–∞–≤—Å–µ–≥–¥–∞ ‚úÖ\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {}\n–ê–∫—Ç–∏–≤–Ω—ã—Ö Premium: {}",
        'admin_commands': "üîß –ê–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã",
        'arbitrage_locked': "üîí –ê—Ä–±–∏—Ç—Ä–∞–∂ ‚Äî —Ñ—É–Ω–∫—Ü–∏—è PREMIUM!\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /premium –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ ($4.99/–º–µ—Å).",
        'arbitrage_opportunity': "üí° –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∞—Ä–±–∏—Ç—Ä–∞–∂–∞! –ë–∏—Ä–∂–∞ 1: ${:,.2f} USDT, –ë–∏—Ä–∂–∞ 2: ${:,.2f} USDT, –†–∞–∑–Ω–∏—Ü–∞: ${:,.2f} USDT",
        'arbitrage_none': "‚ùå –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
        'intro': (
            "üéâ **–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ CryptoAlert Pro!** üöÄ\n\n"
            "–Ø –ø–æ–º–æ–≥—É –≤–∞–º —Å–ª–µ–¥–∏—Ç—å –∑–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞–º–∏!\n"
            "1Ô∏è‚É£ **–¶–µ–Ω—ã**: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /price <–º–æ–Ω–µ—Ç–∞> –∏–ª–∏ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ.\n"
            "2Ô∏è‚É£ **–ü–æ—Ä—Ç—Ñ–µ–ª—å**: –î–æ–±–∞–≤–ª—è–π—Ç–µ –∞–∫—Ç–∏–≤—ã —Å /portfolio add.\n"
            "3Ô∏è‚É£ **–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è**: –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∞–ª–µ—Ä—Ç—ã —Å /alert.\n"
            "4Ô∏è‚É£ **–ü—Ä–µ–º–∏—É–º**: –†–∞–∑–±–ª–æ–∫–∏—Ä—É–π—Ç–µ –∞—Ä–±–∏—Ç—Ä–∞–∂ —Å /premium.\n"
            "5Ô∏è‚É£ **–ë–∏—Ä–∂–∏**: –õ—É—á—à–∏–µ –ø–ª–æ—â–∞–¥–∫–∏ —Å –±–æ–Ω—É—Å–∞–º–∏ üí∞\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ!"
        ),
        'select_coin': "–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–Ω–µ—Ç—É:",
        'select_action': "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        'select_language': "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
        'language_set': "‚úÖ –Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {}",
        'stats': "üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞**\n–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {}\n–ê–∫—Ç–∏–≤–Ω—ã—Ö –ø—Ä–µ–º–∏—É–º: {}\n–†–µ—Ñ–µ—Ä–∞–ª–æ–≤: {}",
        'calc_profit': (
            "**–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–∏–±—ã–ª–∏ –¥–ª—è {}**\n"
            "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {}\n"
            "–¶–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏: ${:,.2f}\n"
            "–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: ${:,.2f}\n"
            "–ü—Ä–∏–±—ã–ª—å/–£–±—ã—Ç–æ–∫: ${:+,.2f}"
        ),
        'calc_profit_usage': "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /calc_profit <–º–æ–Ω–µ—Ç–∞> <–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ> <—Ü–µ–Ω–∞_–ø–æ–∫—É–ø–∫–∏>",
        'coins': "üìà –î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–Ω–µ—Ç—ã:\n{}",
        'error_price': "‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã.",
        'error_trend': "‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–∞.",
        'error_coins': "‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –º–æ–Ω–µ—Ç.",
        'chart_error': "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞.",
        'chart_xlabel': "–í—Ä–µ–º—è",
        'chart_ylabel': "–¶–µ–Ω–∞ (USD)",
        'chart_title': "–ì—Ä–∞—Ñ–∏–∫ —Ü–µ–Ω—ã {} (24—á)",
        'exchanges': "üí∞ **–õ—É—á—à–∏–µ –ö—Ä–∏–ø—Ç–æ–±–∏—Ä–∂–∏**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–ª–æ—â–∞–¥–∫—É:",
        'exchange_info': "**{}**\n{}\n\nüéÅ –ë–æ–Ω—É—Å: {}\nüí∞ –í–∞—à–∞ –∫–æ–º–∏—Å—Å–∏—è: {}\n\nüîó –í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:",
        'ref_earnings': "üí∏ **–í–∞—à –∑–∞—Ä–∞–±–æ—Ç–æ–∫ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤**\n\n–í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –∫–æ–º–∏—Å—Å–∏—é —Å —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–±–æ—Ä–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª–∏—Å—å –ø–æ –≤–∞—à–∏–º —Å—Å—ã–ª–∫–∞–º:\n\n‚Ä¢ Binance: 40% –æ—Ç –∏—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π\n‚Ä¢ Bybit: 30% –æ—Ç –∏—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π\n‚Ä¢ KuCoin: 45% –æ—Ç –∏—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π\n‚Ä¢ MEXC: 35% –æ—Ç –∏—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π\n‚Ä¢ Gate.io: 25% –æ—Ç –∏—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∏—Å—Å–∏–π\n\nüí∞ –ü–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥ –æ—Ç –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–≤–ª–µ—á—ë–Ω–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞!",
        'setup_ref': "üîß **–ö–∞–∫ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–µ —Å—Å—ã–ª–∫–∏:**\n\n1. –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è –≤ –ø–∞—Ä—Ç–Ω—ë—Ä—Å–∫–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö –±–∏—Ä–∂\n2. –ü–æ–ª—É—á–∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–µ –∫–æ–¥—ã\n3. –ó–∞–º–µ–Ω–∏ 'YOUR_CODE' –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±–æ—Ç–∞\n4. –î–µ–ª–∏—Å—å —Å—Å—ã–ª–∫–∞–º–∏ –∏ –ø–æ–ª—É—á–∞–π –ø–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥!",
        'binance_info': "üíé –õ—É—á—à–∞—è –±–∏—Ä–∂–∞ –¥–ª—è —Ç—Ä–µ–π–¥–∏–Ω–≥–∞",
        'custom_coins': "ü™ô –í–∞—à–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–æ–Ω–µ—Ç—ã",
        'add_custom_coin': "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–≤–æ—é –º–æ–Ω–µ—Ç—É",
        'manage_custom_coins': "‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç–∞–º–∏",
        'custom_coin_added': "‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –º–æ–Ω–µ—Ç–∞ '{}' –¥–æ–±–∞–≤–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!",
        'custom_coin_removed': "üóëÔ∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –º–æ–Ω–µ—Ç–∞ '{}' —É–¥–∞–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!",
        'enter_coin_id': "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ CoinGecko ID –¥–ª—è –º–æ–Ω–µ—Ç—ã, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å.\n\n–ü—Ä–∏–º–µ—Ä: bitcoin, ethereum, cardano\n\n–í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ ID –º–æ–Ω–µ—Ç –Ω–∞: https://www.coingecko.com",
        'no_custom_coins': "–í—ã –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–æ–Ω–µ—Ç—ã.",
        'custom_coins_list': "–í–∞—à–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–æ–Ω–µ—Ç—ã:\n{}"
    }
}

def get_lang(user_id: int) -> str:
    return user_settings.get(user_id, {}).get('lang', 'ru')

def t(user_id: int, key: str, *args) -> str:
    lang = get_lang(user_id)
    text = LANGUAGES[lang].get(key, LANGUAGES['ru'][key])
    return text.format(*args) if args else text

def get_user_id(update: Update) -> int:
    return update.effective_user.id

def is_admin(user_id: int) -> bool:
    return user_id == ADMIN_ID

def get_price(coin_id: str = 'bitcoin', vs_currency: str = 'usd') -> tuple:
    try:
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –º–æ–Ω–µ—Ç—ã
        if coin_id.lower() in POPULAR_COINS:
            actual_coin_id = POPULAR_COINS[coin_id.lower()]
        else:
            actual_coin_id = coin_id.lower()
        
        url = f"https://api.coingecko.com/api/v3/simple/price?ids={actual_coin_id}&vs_currencies={vs_currency}&include_24hr_change=true"
        logger.info(f"Requesting price for {actual_coin_id} from {url}")
        
        response = requests.get(url, timeout=15)
        response.raise_for_status()
        data = response.json()
        
        logger.info(f"API Response: {data}")
        
        if actual_coin_id not in data:
            # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –º–æ–Ω–µ—Ç—É –ø–æ —Å–∏–º–≤–æ–ª—É
            logger.warning(f"No data for {actual_coin_id}, trying to search...")
            search_url = f"https://api.coingecko.com/api/v3/search?query={coin_id}"
            search_response = requests.get(search_url, timeout=10)
            if search_response.status_code == 200:
                search_data = search_response.json()
                if search_data['coins']:
                    # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é –º–æ–Ω–µ—Ç—É
                    found_coin = search_data['coins'][0]
                    actual_coin_id = found_coin['id']
                    logger.info(f"Found coin: {actual_coin_id}")
                    
                    # –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Ü–µ–Ω—ã
                    url = f"https://api.coingecko.com/api/v3/simple/price?ids={actual_coin_id}&vs_currencies={vs_currency}&include_24hr_change=true"
                    response = requests.get(url, timeout=15)
                    response.raise_for_status()
                    data = response.json()
            
        if actual_coin_id not in data:
            logger.error(f"No data for {actual_coin_id} in API response. Available coins: {list(data.keys())}")
            return None, None
            
        price = data[actual_coin_id].get(vs_currency)
        change_24h = data[actual_coin_id].get(f"{vs_currency}_24h_change")
        
        if price is None or change_24h is None:
            logger.error(f"Incomplete data for {actual_coin_id}: price={price}, change_24h={change_24h}")
            return None, None
            
        return price, change_24h
        
    except requests.exceptions.Timeout:
        logger.error(f"Timeout fetching price for {coin_id}")
        return None, None
    except requests.exceptions.RequestException as e:
        logger.error(f"Request error fetching price for {coin_id}: {e}")
        return None, None
    except Exception as e:
        logger.error(f"Unexpected error fetching price for {coin_id}: {e}")
        return None, None

def check_arbitrage(user_id: int, coin_id: str = 'bitcoin'):
    try:
        price1 = 120000 + random.randint(-5000, 5000)
        price2 = 120000 + random.randint(-5000, 5000)
        spread = abs(price1 - price2)
        if spread > 1000:
            return t(user_id, 'arbitrage_opportunity', price1, price2, spread)
        return t(user_id, 'arbitrage_none')
    except Exception as e:
        logger.error(f"Error checking arbitrage: {e}")
        return None

def get_trend_recommendation(change_24h: float) -> str:
    if change_24h > 8:
        return "üü¢ STRONG BUY üìà"
    elif change_24h > 3:
        return "üü° BUY üìà"
    elif change_24h < -8:
        return "üî¥ STRONG SELL üìâ"
    elif change_24h < -3:
        return "üü† SELL üìâ"
    else:
        return "üü° HOLD ‚û°Ô∏è"

def calculate_portfolio_profit(user_id):
    try:
        portfolio = user_portfolio.get(user_id, {})
        total_value = 0
        total_invested = 0
        for coin, data in portfolio.items():
            price, _ = get_price(coin)
            if price:
                total_value += data['amount'] * price
                total_invested += data['invested']
        profit = total_value - total_invested
        return total_value, total_invested, profit
    except Exception as e:
        logger.error(f"Error calculating portfolio for user {user_id}: {e}")
        return 0, 0, 0

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} started bot")
    
    user_settings[user_id] = user_settings.get(user_id, {'lang': 'ru', 'alerts': {}, 'seen_intro': False, 'custom_coins': []})
    user_portfolio[user_id] = user_portfolio.get(user_id, {})
    user_referrals[user_id] = user_referrals.get(user_id, {'invited': 0, 'referral_code': f"REF{user_id}"})
    
    if is_admin(user_id):
        user_premium[user_id] = datetime.max
        logger.info(f"Admin {user_id} granted permanent Premium")
    
    # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    if not user_settings[user_id].get('seen_intro'):
        intro_message = t(user_id, 'intro')
        user_settings[user_id]['seen_intro'] = True
    else:
        intro_message = f"{t(user_id, 'welcome')}\n\n{t(user_id, 'referral').format(user_referrals[user_id]['referral_code'])}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    
    keyboard = [
        [InlineKeyboardButton("üí∞ –¶–µ–Ω—ã", callback_data="price_menu"),
         InlineKeyboardButton("üìä –ü–æ—Ä—Ç—Ñ–µ–ª—å", callback_data="portfolio_menu")],
        [InlineKeyboardButton("üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data="alert_menu"),
         InlineKeyboardButton("üëë –ü—Ä–µ–º–∏—É–º", callback_data="premium")],
        [InlineKeyboardButton("üí∏ –ë–∏—Ä–∂–∏ + –ë–æ–Ω—É—Å—ã", callback_data="exchanges")],
        [InlineKeyboardButton("üîß –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="admin") if is_admin(user_id) else InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")],
        [InlineKeyboardButton("üá∫üá∏ EN | üá∑üá∫ RU | üá™üá∏ ES", callback_data="lang_menu")]
    ]
    reply_keyboard = [
        ["üí∞ –¶–µ–Ω—ã", "üìä –ü–æ—Ä—Ç—Ñ–µ–ª—å"],
        ["üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", "üëë –ü—Ä–µ–º–∏—É–º"],
        ["üí∏ –ë–∏—Ä–∂–∏", "‚ÑπÔ∏è –ü–æ–º–æ—â—å"]
    ]
    if is_admin(user_id):
        reply_keyboard.append(["üîß –ê–¥–º–∏–Ω"])
    reply_markup = InlineKeyboardMarkup(keyboard)
    persistent_keyboard = ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)
    
    await update.message.reply_text(intro_message, reply_markup=reply_markup, parse_mode='Markdown')
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=persistent_keyboard)
    logger.info(f"User {user_id} successfully started bot")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    text = update.message.text
    
    logger.info(f"User {user_id} sent text: {text}")
    
    if text == "üí∞ –¶–µ–Ω—ã":
        await price_menu(update, context)
    elif text == "üìä –ü–æ—Ä—Ç—Ñ–µ–ª—å":
        await portfolio_menu(update, context)
    elif text == "üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è":
        await alert_menu(update, context)
    elif text == "üëë –ü—Ä–µ–º–∏—É–º":
        await premium_cmd(update, context)
    elif text == "üí∏ –ë–∏—Ä–∂–∏":
        await exchanges_menu(update, context)
    elif text == "‚ÑπÔ∏è –ü–æ–º–æ—â—å":
        await help_cmd(update, context)
    elif text == "üîß –ê–¥–º–∏–Ω" and is_admin(user_id):
        await admin_cmd(update, context)
    else:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –∏–ª–∏ –∫–æ–º–∞–Ω–¥—ã. –î–ª—è –ø–æ–º–æ—â–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help")

async def price_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    
    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –º–æ–Ω–µ—Ç
    keyboard = []
    row = []
    
    # –ü–µ—Ä–≤—ã–µ 6 –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –º–æ–Ω–µ—Ç
    popular_coins_list = list(POPULAR_COINS.keys())[:6]
    for i, coin in enumerate(popular_coins_list):
        row.append(InlineKeyboardButton(coin.upper(), callback_data=f"price_{coin}"))
        if len(row) == 2:  # 2 –∫–Ω–æ–ø–∫–∏ –≤ —Ä—è–¥
            keyboard.append(row)
            row = []
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –∫–Ω–æ–ø–∫–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
    if row:
        keyboard.append(row)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–Ω–µ—Ç
    custom_coins = user_settings.get(user_id, {}).get('custom_coins', [])
    if custom_coins:
        keyboard.append([InlineKeyboardButton(t(user_id, 'custom_coins'), callback_data="custom_coins_menu")])
    
    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
    keyboard.extend([
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–≤–æ—é –º–æ–Ω–µ—Ç—É", callback_data="add_custom_coin")],
        [InlineKeyboardButton("üìã –í—Å–µ –º–æ–Ω–µ—Ç—ã", callback_data="all_coins")],
        [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="main_menu")]
    ])
    
    await update.message.reply_text(t(user_id, 'select_coin'), reply_markup=InlineKeyboardMarkup(keyboard))

async def custom_coins_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    await query.answer()
    
    custom_coins = user_settings.get(user_id, {}).get('custom_coins', [])
    
    if not custom_coins:
        keyboard = [
            [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–µ—Ç—É", callback_data="add_custom_coin")],
            [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="price_menu")]
        ]
        await query.edit_message_text(t(user_id, 'no_custom_coins'), reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    keyboard = []
    row = []
    
    for i, coin in enumerate(custom_coins):
        row.append(InlineKeyboardButton(coin.upper(), callback_data=f"price_{coin}"))
        if len(row) == 2:
            keyboard.append(row)
            row = []
    
    if row:
        keyboard.append(row)
    
    keyboard.extend([
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â—ë", callback_data="add_custom_coin")],
        [InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –º–æ–Ω–µ—Ç—É", callback_data="remove_custom_coin")],
        [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="price_menu")]
    ])
    
    coins_list = "\n".join([f"‚Ä¢ {coin.upper()}" for coin in custom_coins])
    await query.edit_message_text(
        f"{t(user_id, 'custom_coins_list').format(coins_list)}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–Ω–µ—Ç—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ü–µ–Ω—ã:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def add_custom_coin_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    await query.answer()
    
    await query.edit_message_text(t(user_id, 'enter_coin_id'))
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    context.user_data['waiting_for_coin_id'] = True

async def handle_custom_coin_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    
    if context.user_data.get('waiting_for_coin_id'):
        coin_id = update.message.text.strip().lower()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –º–æ–Ω–µ—Ç–∞
        price, change = get_price(coin_id)
        if price is None:
            await update.message.reply_text(
                f"‚ùå –ú–æ–Ω–µ—Ç–∞ '{coin_id}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.\n"
                f"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å ID –Ω–∞ https://www.coingecko.com\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:"
            )
            return
        
        # –î–æ–±–∞–≤–ª—è–µ–º –º–æ–Ω–µ—Ç—É –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Å–ø–∏—Å–æ–∫
        if 'custom_coins' not in user_settings[user_id]:
            user_settings[user_id]['custom_coins'] = []
        
        if coin_id not in user_settings[user_id]['custom_coins']:
            user_settings[user_id]['custom_coins'].append(coin_id)
            await update.message.reply_text(
                t(user_id, 'custom_coin_added', coin_id) + 
                f"\n\n–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: ${price:,.2f}\n"
                f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é —Ü–µ–Ω –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –º–æ–Ω–µ—Ç–µ."
            )
        else:
            await update.message.reply_text(f"‚úÖ –ú–æ–Ω–µ—Ç–∞ '{coin_id}' —É–∂–µ –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ!")
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        context.user_data['waiting_for_coin_id'] = False

async def remove_custom_coin_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    await query.answer()
    
    custom_coins = user_settings.get(user_id, {}).get('custom_coins', [])
    
    if not custom_coins:
        await query.edit_message_text(t(user_id, 'no_custom_coins'))
        return
    
    keyboard = []
    for coin in custom_coins:
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {coin.upper()}", callback_data=f"remove_{coin}")])
    
    keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="custom_coins_menu")])
    
    await query.edit_message_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–Ω–µ—Ç—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def portfolio_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    keyboard = [
        [InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å –∞–∫—Ç–∏–≤", callback_data="portfolio_add"),
         InlineKeyboardButton("–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—å", callback_data="portfolio_view")],
        [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="main_menu")]
    ]
    await update.message.reply_text(t(user_id, 'select_action'), reply_markup=InlineKeyboardMarkup(keyboard))

async def alert_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ: /alert <–º–æ–Ω–µ—Ç–∞> <–ø—Ä–æ—Ü–µ–Ω—Ç>\n\n–ü—Ä–∏–º–µ—Ä: /alert bitcoin 5")

async def exchanges_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    keyboard = [
        [InlineKeyboardButton("Binance üöÄ", callback_data="exchange_binance"),
         InlineKeyboardButton("Bybit ‚ö°", callback_data="exchange_bybit")],
        [InlineKeyboardButton("KuCoin üíé", callback_data="exchange_kucoin"),
         InlineKeyboardButton("MEXC üìà", callback_data="exchange_mexc")],
        [InlineKeyboardButton("Gate.io üõ°Ô∏è", callback_data="exchange_gateio")],
        [InlineKeyboardButton("üí∞ –ö–∞–∫ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å", callback_data="ref_earnings_info"),
         InlineKeyboardButton("üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞", callback_data="ref_setup_info")],
        [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="main_menu")]
    ]
    await update.message.reply_text(t(user_id, 'exchanges'), reply_markup=InlineKeyboardMarkup(keyboard))

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    await query.answer()
    
    logger.info(f"Button callback from user {user_id}: {query.data}")
    
    if query.data == "price_menu":
        await price_menu(update, context)
    elif query.data.startswith("price_"):
        coin = query.data.split("_")[1]
        
        if coin == "other":
            await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ: /price <coin>\n\n–ü—Ä–∏–º–µ—Ä: /price bitcoin")
        else:
            price, change_24h = get_price(coin)
            if price is not None and change_24h is not None:
                recommendation = get_trend_recommendation(change_24h)
                response = t(user_id, 'price', coin.upper(), price, change_24h) + f"\n\nüéØ {recommendation}"
                await query.edit_message_text(response, parse_mode='Markdown')
            else:
                await query.edit_message_text(
                    f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è {coin.upper()}\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
                    f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ\n" 
                    f"‚Ä¢ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ\n"
                    f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—É: /price {coin}"
                )
    elif query.data == "custom_coins_menu":
        await custom_coins_menu(update, context)
    elif query.data == "add_custom_coin":
        await add_custom_coin_handler(update, context)
    elif query.data == "remove_custom_coin":
        await remove_custom_coin_handler(update, context)
    elif query.data.startswith("remove_"):
        coin_to_remove = query.data.split("_")[1]
        if 'custom_coins' in user_settings[user_id] and coin_to_remove in user_settings[user_id]['custom_coins']:
            user_settings[user_id]['custom_coins'].remove(coin_to_remove)
            await query.edit_message_text(t(user_id, 'custom_coin_removed', coin_to_remove))
        else:
            await query.edit_message_text(f"‚ùå –ú–æ–Ω–µ—Ç–∞ '{coin_to_remove}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ.")
    elif query.data == "all_coins":
        await coins_cmd(update, context)
    elif query.data == "portfolio_menu":
        keyboard = [
            [InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å –∞–∫—Ç–∏–≤", callback_data="portfolio_add"),
             InlineKeyboardButton("–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—å", callback_data="portfolio_view")],
            [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="main_menu")]
        ]
        await query.edit_message_text(t(user_id, 'select_action'), reply_markup=InlineKeyboardMarkup(keyboard))
    elif query.data == "portfolio_add":
        await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ: /portfolio add <coin> <amount> <invested>\n\n–ü—Ä–∏–º–µ—Ä: /portfolio add bitcoin 0.1 2500")
    elif query.data == "portfolio_view":
        total_value, total_invested, profit = calculate_portfolio_profit(user_id)
        portfolio = user_portfolio.get(user_id, {})
        if not portfolio:
            await query.edit_message_text(t(user_id, 'portfolio_empty'))
            return
        response = f"üìä {t(user_id, 'portfolio')}:\n\n"
        for coin, data in portfolio.items():
            price, _ = get_price(coin)
            value = data['amount'] * (price or 0)
            profit_coin = value - data['invested']
            response += f"**{coin.upper()}**: {data['amount']}\n"
            response += f"  –ó–Ω–∞—á–µ–Ω–∏–µ: ${value:,.2f} | –ò–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ: ${data['invested']:,.2f}\n"
            response += f"  –ü—Ä–∏–±—ã–ª—å: ${profit_coin:+,.2f}\n\n"
        response += f"üíé –ò–¢–û–ì–û:\n–ó–Ω–∞—á–µ–Ω–∏–µ: ${total_value:,.2f} | –ü—Ä–∏–±—ã–ª—å: ${profit:+,.2f}"
        await query.edit_message_text(response, parse_mode='Markdown')
    elif query.data == "alert_menu":
        await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ: /alert <coin> <percent>\n\n–ü—Ä–∏–º–µ—Ä: /alert bitcoin 5")
    elif query.data == "exchanges":
        await exchanges_menu(update, context)
    elif query.data.startswith("exchange_"):
        exchange = query.data.split("_")[1]
        if exchange in REFERRAL_PROGRAMS:
            ref_data = REFERRAL_PROGRAMS[exchange]
            keyboard = [
                [InlineKeyboardButton("üîó –û—Ç–∫—Ä—ã—Ç—å —Å—Å—ã–ª–∫—É", url=ref_data['link'])],
                [InlineKeyboardButton("üí∞ –í—Å–µ –±–∏—Ä–∂–∏", callback_data="exchanges"),
                 InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="main_menu")]
            ]
            response = t(user_id, 'exchange_info', 
                        exchange.upper(), 
                        ref_data['description'], 
                        ref_data['bonus'],
                        ref_data['commission'])
            await query.edit_message_text(response, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
    elif query.data == "ref_earnings_info":
        await query.edit_message_text(t(user_id, 'ref_earnings'), parse_mode='Markdown')
    elif query.data == "ref_setup_info":
        await query.edit_message_text(t(user_id, 'setup_ref'), parse_mode='Markdown')
    elif query.data == "premium":
        await premium_cmd(update, context)
    elif query.data == "admin" and is_admin(user_id):
        await admin_cmd(update, context)
    elif query.data == "help":
        await help_cmd(update, context)
    elif query.data == "lang_menu":
        keyboard = [
            [InlineKeyboardButton("üá∫üá∏ English", callback_data="lang_en"),
             InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="lang_ru")],
            [InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="lang_es")],
            [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="main_menu")]
        ]
        await query.edit_message_text(t(user_id, 'select_language'), reply_markup=InlineKeyboardMarkup(keyboard))
    elif query.data.startswith('lang_'):
        lang = query.data.split('_')[1]
        user_settings[user_id]['lang'] = lang
        await query.edit_message_text(
            t(user_id, 'language_set', f"‚úÖ –Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {lang.upper()}\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –Ω–∞—á–∞–ª–∞!")
        )
        logger.info(f"User {user_id} changed language to {lang}")
    elif query.data == "main_menu":
        await start(update, context)

async def price_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called price_cmd with args: {context.args}")
    
    if not context.args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /price <–º–æ–Ω–µ—Ç–∞>\n–ü—Ä–∏–º–µ—Ä: /price bitcoin")
        return
        
    coin = context.args[0].lower()
    
    price, change_24h = get_price(coin)
    
    if price is not None and change_24h is not None:
        recommendation = get_trend_recommendation(change_24h)
        response = (
            f"**{coin.upper()}**\n"
            f"üí∞ {t(user_id, 'price', coin.upper(), price, change_24h)}\n"
            f"üéØ {recommendation}"
        )
        await update.message.reply_text(response, parse_mode='Markdown')
    else:
        await update.message.reply_text(
            f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è {coin.upper()}\n"
            f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
            f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ\n"
            f"‚Ä¢ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ\n"
            f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã\n"
            f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å ID –º–æ–Ω–µ—Ç—ã –Ω–∞ https://www.coingecko.com"
        )
        logger.error(f"Failed to get price for {coin} for user {user_id}")

async def alert_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called alert_cmd with args: {context.args}")
    if len(context.args) < 2:
        await update.message.reply_text(t(user_id, 'alert_usage'))
        return
    
    try:
        coin, threshold = context.args[0].lower(), float(context.args[1])
        user_settings[user_id]['alerts'][coin] = threshold
        await update.message.reply_text(
            t(user_id, 'alert_set', coin.upper(), threshold)
        )
        logger.info(f"User {user_id} set alert for {coin} at {threshold}%")
    except ValueError:
        await update.message.reply_text(t(user_id, 'error_invalid_percent'))
        logger.error(f"Invalid percent format for user {user_id}")

async def portfolio_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called portfolio_cmd with args: {context.args}")
    
    if not context.args:
        await update.message.reply_text(t(user_id, 'portfolio_usage'))
        return
    
    subcommand = context.args[0].lower()
    
    if subcommand == 'add':
        if len(context.args) < 4:
            await update.message.reply_text(t(user_id, 'portfolio_add_usage'))
            return
        try:
            coin, amount, invested = context.args[1].lower(), float(context.args[2]), float(context.args[3])
            user_portfolio[user_id] = user_portfolio.get(user_id, {})
            user_portfolio[user_id][coin] = {'amount': amount, 'invested': invested}
            await update.message.reply_text(t(user_id, 'portfolio_added', amount, coin.upper(), invested))
            logger.info(f"User {user_id} added {amount} {coin} to portfolio")
        except ValueError:
            await update.message.reply_text(t(user_id, 'error_invalid_value'))
            logger.error(f"Invalid format for portfolio add for user {user_id}")
    
    elif subcommand == 'view':
        total_value, total_invested, profit = calculate_portfolio_profit(user_id)
        portfolio = user_portfolio.get(user_id, {})
        
        if not portfolio:
            await update.message.reply_text(t(user_id, 'portfolio_empty'))
            return
        
        response = f"üìä {t(user_id, 'portfolio')}:\n\n"
        for coin, data in portfolio.items():
            price, _ = get_price(coin)
            value = data['amount'] * (price or 0)
            profit_coin = value - data['invested']
            response += f"**{coin.upper()}**: {data['amount']}\n"
            response += f"  –ó–Ω–∞—á–µ–Ω–∏–µ: ${value:,.2f} | –ò–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ: ${data['invested']:,.2f}\n"
            response += f"  –ü—Ä–∏–±—ã–ª—å: ${profit_coin:+,.2f}\n\n"
        response += f"üíé –ò–¢–û–ì–û:\n–ó–Ω–∞—á–µ–Ω–∏–µ: ${total_value:,.2f} | –ü—Ä–∏–±—ã–ª—å: ${profit:+,.2f}"
        await update.message.reply_text(response, parse_mode='Markdown')
        logger.info(f"User {user_id} viewed portfolio")

async def arbitrage_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called arbitrage_cmd")
    try:
        if user_id in PREMIUM_USERS or (user_id in user_premium and user_premium[user_id] > datetime.now()):
            result = check_arbitrage(user_id)
            await update.message.reply_text(result)
            logger.info(f"User {user_id} used arbitrage command")
        else:
            await update.message.reply_text(t(user_id, 'arbitrage_locked'))
    except Exception as e:
        logger.error(f"Error in arbitrage_cmd: {e}")
        await update.message.reply_text(f"–û—à–∏–±–∫–∞: {str(e)}")

async def trend_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called trend_cmd with args: {context.args}")
    coin = context.args[0].lower() if context.args else 'bitcoin'
    price, change_24h = get_price(coin)
    
    if price:
        recommendation = get_trend_recommendation(change_24h)
        response = (
            f"**{coin.upper()}**\n"
            f"üí∞ {t(user_id, 'price', coin.upper(), price, change_24h)}\n"
            f"üéØ {recommendation}"
        )
        await update.message.reply_text(response, parse_mode='Markdown')
    else:
        await update.message.reply_text(t(user_id, 'error_trend'))
        logger.error(f"Failed to get trend for {coin} for user {user_id}")

async def exchanges_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫–æ –≤—Å–µ–º –±–∏—Ä–∂–∞–º"""
    await exchanges_menu(update, context)

async def binance_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°—Ç–∞—Ä–∞—è –∫–æ–º–∞–Ω–¥–∞ binance - –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ exchanges"""
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called binance_cmd")
    
    # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –º–µ–Ω—é –±–∏—Ä–∂
    await exchanges_menu(update, context)

async def premium_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called premium_cmd")
    
    if is_admin(user_id):
        user_premium[user_id] = datetime.max
        await update.message.reply_text(t(user_id, 'admin_premium'))
        logger.info(f"Admin {user_id} activated Premium")
        return
    
    prices = [LabeledPrice(t(user_id, 'premium_label'), 499)]
    
    await context.bot.send_invoice(
        chat_id=update.effective_chat.id,
        title=t(user_id, 'premium_title'),
        description=t(user_id, 'premium_description'),
        payload=f"premium_1month_{user_id}",
        provider_token="",
        currency="XTR",
        prices=prices,
        start_parameter="premium-payment",
        need_name=False,
        need_phone_number=False,
        need_email=False,
        need_shipping_address=False,
        is_flexible=False
    )
    logger.info(f"User {user_id} requested Premium invoice")

async def testpremium_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called testpremium_cmd")
    
    if not is_admin(user_id):
        await update.message.reply_text(t(user_id, 'admin_only'))
        logger.info(f"User {user_id} tried testpremium - access denied")
        return
    
    prices = [LabeledPrice(t(user_id, 'test_premium_label'), 1)]
    
    await context.bot.send_invoice(
        chat_id=update.effective_chat.id,
        title=t(user_id, 'test_premium_title'),
        description=t(user_id, 'test_premium_description'),
        payload=f"test_premium_{user_id}",
        provider_token="",
        currency="XTR",
        prices=prices,
        start_parameter="test-payment",
        need_name=False,
        need_phone_number=False,
        need_email=False,
        need_shipping_address=False,
        is_flexible=False
    )
    await update.message.reply_text(t(user_id, 'test_premium'))
    logger.info(f"Admin {user_id} requested test Premium invoice")

async def admin_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called admin_cmd")
    
    if not is_admin(user_id):
        await update.message.reply_text(t(user_id, 'admin_only'))
        logger.info(f"User {user_id} tried admin_cmd - access denied")
        return
    
    user_premium[user_id] = datetime.max
    
    total_users = len(user_settings)
    active_premium = sum(1 for uid, expiry in user_premium.items() if expiry > datetime.now())
    
    await update.message.reply_text(
        t(user_id, 'admin_status', total_users, active_premium) + "\n\n"
        f"{t(user_id, 'admin_commands')}:\n"
        "/admin - –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\n"
        "/testpremium - –¢–µ—Å—Ç–æ–≤—ã–π –ø–ª–∞—Ç—ë–∂ (1 Star)\n"
        "/arbitrage - –¢–µ—Å—Ç –ø—Ä–µ–º–∏—É–º-—Ñ—É–Ω–∫—Ü–∏–∏\n"
        "/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞"
    )
    logger.info(f"Admin {user_id} accessed admin panel")

async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called status_cmd")
    if user_id in user_premium and user_premium[user_id] > datetime.now():
        if user_premium[user_id] == datetime.max:
            status = t(user_id, 'premium_status_admin')
            expiry = t(user_id, 'premium_expiry_never')
        else:
            status = t(user_id, 'premium_status_active')
            expiry = user_premium[user_id].strftime("%Y-%m-%d %H:%M")
    else:
        status = t(user_id, 'premium_status_inactive')
        expiry = t(user_id, 'premium_expiry_none')
    await update.message.reply_text(
        t(user_id, 'premium_status', status, expiry)
    )
    logger.info(f"User {user_id} checked premium status")

async def pre_checkout_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.pre_checkout_query
    user_id = int(query.invoice_payload.split('_')[-1]) if '_' in query.invoice_payload else 0
    logger.info(f"Pre-checkout query for user {user_id}: {query.invoice_payload}")
    
    if is_admin(user_id):
        await query.answer(ok=True)
        return
    
    if query.invoice_payload.startswith("premium_1month_") or query.invoice_payload.startswith("test_premium_"):
        await query.answer(ok=True)
    else:
        await query.answer(ok=False, error_message=t(user_id, 'invalid_product'))
        logger.error(f"Invalid product for user {user_id}: {query.invoice_payload}")

async def successful_payment_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    payment = update.message.successful_payment
    
    logger.info(f"Payment received from {user_id}: {payment.total_amount} Stars")
    
    if is_admin(user_id):
        user_premium[user_id] = datetime.max
        await update.message.reply_text(t(user_id, 'admin_premium'))
        logger.info(f"Admin {user_id} got permanent Premium: {payment.total_amount} Stars")
        return
    
    if payment.invoice_payload.startswith("premium_1month_"):
        user_premium[user_id] = datetime.now() + timedelta(days=30)
        await update.message.reply_text(t(user_id, 'premium_success'))
        logger.info(f"Premium activated for {user_id}: {payment.total_amount} Stars")
    
    elif payment.invoice_payload.startswith("test_premium_"):
        user_premium[user_id] = datetime.now() + timedelta(days=30)
        await update.message.reply_text(
            t(user_id, 'test_premium_success')
        )
        logger.info(f"Test payment for {user_id}: {payment.total_amount} Stars")

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called help_cmd")
    help_text = f"ü§ñ {t(user_id, 'commands')}\n\n"
    help_text += (
        f"/start - {t(user_id, 'help_start')}\n"
        f"/price <coin> - {t(user_id, 'help_price')}\n"
        f"/alert <coin> <percent> - {t(user_id, 'help_alert')}\n"
        f"/portfolio add <coin> <amount> <invested> - {t(user_id, 'help_portfolio_add')}\n"
        f"/portfolio view - {t(user_id, 'help_portfolio_view')}\n"
        f"/arbitrage - {t(user_id, 'help_arbitrage')}\n"
        f"/trend <coin> - {t(user_id, 'help_trend')}\n"
        f"/exchanges - {t(user_id, 'help_exchanges')}\n"
        f"/binance - Binance with bonuses\n"
        f"/premium - {t(user_id, 'help_premium')}\n"
        f"/status - {t(user_id, 'help_status')}\n"
        f"/coins - {t(user_id, 'help_coins')}\n"
        f"/chart <coin> - {t(user_id, 'help_chart')}\n"
        f"/calc_profit <coin> <amount> <buy_price> - {t(user_id, 'help_calc_profit')}\n"
        f"/commands - {t(user_id, 'help_commands')}\n"
    )
    
    if is_admin(user_id):
        help_text += f"\nüîß {t(user_id, 'admin_commands')}:\n"
        help_text += (
            f"/admin - {t(user_id, 'help_admin')}\n"
            f"/testpremium - {t(user_id, 'help_testpremium')}\n"
            f"/stats - {t(user_id, 'help_stats')}\n"
        )
    
    await update.message.reply_text(help_text)
    logger.info(f"Help sent to user {user_id}")

async def commands_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called commands_cmd")
    help_text = f"ü§ñ {t(user_id, 'commands')}\n\n"
    help_text += (
        f"/start - {t(user_id, 'help_start')}\n"
        f"/price <coin> - {t(user_id, 'help_price')}\n"
        f"/alert <coin> <percent> - {t(user_id, 'help_alert')}\n"
        f"/portfolio add <coin> <amount> <invested> - {t(user_id, 'help_portfolio_add')}\n"
        f"/portfolio view - {t(user_id, 'help_portfolio_view')}\n"
        f"/arbitrage - {t(user_id, 'help_arbitrage')}\n"
        f"/trend <coin> - {t(user_id, 'help_trend')}\n"
        f"/exchanges - {t(user_id, 'help_exchanges')}\n"
        f"/binance - Binance with bonuses\n"
        f"/premium - {t(user_id, 'help_premium')}\n"
        f"/status - {t(user_id, 'help_status')}\n"
        f"/coins - {t(user_id, 'help_coins')}\n"
        f"/chart <coin> - {t(user_id, 'help_chart')}\n"
        f"/calc_profit <coin> <amount> <buy_price> - {t(user_id, 'help_calc_profit')}\n"
        f"/commands - {t(user_id, 'help_commands')}\n"
    )
    
    if is_admin(user_id):
        help_text += f"\nüîß {t(user_id, 'admin_commands')}:\n"
        help_text += (
            f"/admin - {t(user_id, 'help_admin')}\n"
            f"/testpremium - {t(user_id, 'help_testpremium')}\n"
            f"/stats - {t(user_id, 'help_stats')}\n"
        )
    
    await update.message.reply_text(help_text)
    logger.info(f"Commands list sent to user {user_id}")

async def coins_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called coins_cmd")
    try:
        url = "https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&per_page=20"
        logger.info(f"Requesting coins list from {url}")
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        coins = response.json()
        response_text = ""
        for coin in coins:
            response_text += f"{coin['symbol'].upper()} - {coin['name']} (ID: {coin['id']})\n"
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–Ω–µ—Ç–∞—Ö
        custom_coins = user_settings.get(user_id, {}).get('custom_coins', [])
        if custom_coins:
            response_text += f"\nü™ô –í–∞—à–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–æ–Ω–µ—Ç—ã:\n"
            for coin in custom_coins:
                response_text += f"{coin.upper()} (ID: {coin})\n"
        
        response_text += f"\nüí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ ID –º–æ–Ω–µ—Ç—ã –¥–ª—è –∫–æ–º–∞–Ω–¥ /price, /alert, /chart"
        
        await update.message.reply_text(t(user_id, 'coins', response_text))
        logger.info(f"Coins list sent to user {user_id}")
    except Exception as e:
        logger.error(f"Error fetching coins: {e}")
        await update.message.reply_text(t(user_id, 'error_coins'))

async def chart_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called chart_cmd with args: {context.args}")
    
    if not context.args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /chart <–º–æ–Ω–µ—Ç–∞>\n–ü—Ä–∏–º–µ—Ä: /chart bitcoin")
        return
        
    coin = context.args[0].lower()
    
    try:
        # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–µ–∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –±—ç–∫–µ–Ω–¥
        plt.switch_backend('Agg')
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
        url = f"https://api.coingecko.com/api/v3/coins/{coin}/market_chart?vs_currency=usd&days=1"
        logger.info(f"Requesting chart data for {coin} from {url}")
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ü–µ–Ω—ã –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
        prices = [p[1] for p in data['prices']]
        times = [datetime.fromtimestamp(p[0]/1000) for p in data['prices']]
        
        # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏ –≤—Ä–µ–º–µ–Ω–∏
        plt.figure(figsize=(12, 6))
        plt.plot(times, prices, 'b-', linewidth=2, label=f"{coin.upper()} Price")
        plt.xlabel(t(user_id, 'chart_xlabel'))
        plt.ylabel(t(user_id, 'chart_ylabel'))
        plt.title(t(user_id, 'chart_title', coin.upper()))
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Å—å X –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
        plt.gcf().autofmt_xdate()
        
        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –¥–ª—è –ø–æ–¥–ø–∏—Å–∏
        current_price, change_24h = get_price(coin)
        caption = f"üìä {t(user_id, 'chart_title', coin.upper())}"
        if current_price:
            caption += f"\nüíµ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: ${current_price:,.2f}"
        if change_24h:
            caption += f"\nüìà –ò–∑–º–µ–Ω–µ–Ω–∏–µ 24—á: {change_24h:+.2f}%"
        
        await update.message.reply_photo(photo=buf, caption=caption)
        plt.close()
        logger.info(f"Chart for {coin} sent to user {user_id}")
        
    except Exception as e:
        logger.error(f"Error generating chart for {coin}: {e}")
        await update.message.reply_text(
            f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {coin.upper()}\n"
            f"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å ID –º–æ–Ω–µ—Ç—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        )

async def calc_profit_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called calc_profit_cmd with args: {context.args}")
    if len(context.args) < 3:
        await update.message.reply_text(t(user_id, 'calc_profit_usage'))
        return
    
    try:
        coin, amount, buy_price = context.args[0].lower(), float(context.args[1]), float(context.args[2])
        current_price, _ = get_price(coin)
        if current_price:
            profit = (current_price - buy_price) * amount
            profit_percent = ((current_price - buy_price) / buy_price) * 100
            response = (
                f"**{t(user_id, 'calc_profit', coin.upper(), amount, buy_price, current_price, profit)}**\n"
                f"üìä –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª–∏: {profit_percent:+.2f}%"
            )
            await update.message.reply_text(response, parse_mode='Markdown')
            logger.info(f"Profit calculated for {coin} for user {user_id}")
        else:
            await update.message.reply_text(t(user_id, 'error_price'))
            logger.error(f"Failed to get price for {coin} for user {user_id}")
    except ValueError:
        await update.message.reply_text(t(user_id, 'error_invalid_value'))
        logger.error(f"Invalid format for calc_profit for user {user_id}")

async def stats_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = get_user_id(update)
    logger.info(f"User {user_id} called stats_cmd")
    if not is_admin(user_id):
        await update.message.reply_text(t(user_id, 'admin_only'))
        logger.info(f"User {user_id} tried stats_cmd - access denied")
        return
    
    total_users = len(user_settings)
    active_premium = sum(1 for uid, expiry in user_premium.items() if expiry > datetime.now())
    total_referrals = sum(r['invited'] for r in user_referrals.values())
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º –º–æ–Ω–µ—Ç–∞–º
    total_custom_coins = sum(len(settings.get('custom_coins', [])) for settings in user_settings.values())
    users_with_custom_coins = sum(1 for settings in user_settings.values() if settings.get('custom_coins'))
    
    response = (
        f"{t(user_id, 'stats', total_users, active_premium, total_referrals)}\n"
        f"ü™ô –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–æ–Ω–µ—Ç—ã: {total_custom_coins}\n"
        f"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º–∏ –º–æ–Ω–µ—Ç–∞–º–∏: {users_with_custom_coins}"
    )
    await update.message.reply_text(response, parse_mode='Markdown')
    logger.info(f"Stats sent to admin {user_id}")

async def price_alert_task(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Starting price_alert_task")
    while True:
        for user_id, settings in user_settings.items():
            for coin, threshold in settings.get('alerts', {}).items():
                price, change_24h = get_price(coin)
                if price and abs(change_24h) >= threshold:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=f"üîî Alert for {coin.upper()} triggered! Change: {change_24h:+.2f}%, Current Price: ${price:,.2f}"
                    )
                    logger.info(f"Alert triggered for user {user_id} on {coin}: {change_24h}%")
        await asyncio.sleep(300)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Update {update} caused error {context.error}")
    print(f"‚ùå ERROR: {context.error}")
    
    try:
        if update and update.effective_chat:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
    except:
        pass

def main():
    print("=" * 50)
    print("üöÄ INITIALIZING CRYPTOALERT PRO BOT...")
    print(f"üì° Token: {TELEGRAM_TOKEN[:10]}...")
    print(f"üëë Admin ID: {ADMIN_ID}")
    print("=" * 50)
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ API
    try:
        price, change = get_price('bitcoin')
        if price:
            print("‚úÖ CoinGecko API is accessible")
        else:
            print("‚ùå CoinGecko API not responding")
    except Exception as e:
        print(f"‚ùå API check failed: {e}")
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    try:
        application = Application.builder().token(TELEGRAM_TOKEN).build()
        print("‚úÖ Application created successfully")
    except Exception as e:
        logger.error(f"Failed to create application: {e}")
        print(f"‚ùå Failed to create application: {e}")
        return
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
    try:
        token_valid = asyncio.run(test_token())
        if not token_valid:
            print("‚ùå Token validation failed - stopping bot")
            return
    except Exception as e:
        logger.error(f"Token validation failed: {e}")
        print(f"‚ùå Token validation failed: {e}")
        return
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞ –º–æ–Ω–µ—Ç
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_coin_input))
    
    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("price", price_cmd))
    application.add_handler(CommandHandler("alert", alert_cmd))
    application.add_handler(CommandHandler("portfolio", portfolio_cmd))
    application.add_handler(CommandHandler("arbitrage", arbitrage_cmd))
    application.add_handler(CommandHandler("trend", trend_cmd))
    application.add_handler(CommandHandler("exchanges", exchanges_cmd))
    application.add_handler(CommandHandler("binance", binance_cmd))
    application.add_handler(CommandHandler("premium", premium_cmd))
    application.add_handler(CommandHandler("testpremium", testpremium_cmd))
    application.add_handler(CommandHandler("admin", admin_cmd))
    application.add_handler(CommandHandler("status", status_cmd))
    application.add_handler(CommandHandler("help", help_cmd))
    application.add_handler(CommandHandler("coins", coins_cmd))
    application.add_handler(CommandHandler("chart", chart_cmd))
    application.add_handler(CommandHandler("calc_profit", calc_profit_cmd))
    application.add_handler(CommandHandler("stats", stats_cmd))
    application.add_handler(CommandHandler("commands", commands_cmd))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(PreCheckoutQueryHandler(pre_checkout_callback))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment_callback))
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
    application.add_error_handler(error_handler)
    
    # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    application.job_queue.run_repeating(price_alert_task, interval=300)
    
    print("‚úÖ All handlers registered")
    print("üîÑ Starting polling...")
    logger.info("Bot started successfully")
    
    # –ó–∞–ø—É—Å–∫ polling —Å –æ—Ç–ª–∞–¥–∫–æ–π
    try:
        application.run_polling(
            drop_pending_updates=True,
            allowed_updates=Update.ALL_TYPES
        )
        print("‚úÖ Polling started successfully")
    except Exception as e:
        logger.error(f"Polling failed: {e}")
        print(f"‚ùå Polling failed: {e}")

if __name__ == "__main__":
    main()